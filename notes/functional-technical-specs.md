Perfect, let’s lock this in as a spec we could hand straight to “dev-you” or Claude and start building.

I’ll call the plugin **“NovaTune”** as a placeholder (we can rename later).

---

# NovaTune – Auto-Tune-Style Vocal Tuner + Harmonizer

**Functional & Technical Specifications – MVP v1**

---

## 1. Product Overview

**NovaTune** is a real-time vocal pitch correction and harmonization plugin aiming to deliver:

* **Auto-Tune–style correction** (subtle to hard-tuned).
* **Real-time vocal harmonies** with user-defined intervals and musical presets.
* **Ultra-low latency** for tracking and live performance.
* **Low CPU usage** to allow multiple instances per project.
* **Fast, intuitive workflow** with a simple “Auto Mode” UI (Graph Mode is Phase 2).

**Target users**

* Producers and engineers in home and pro studios.
* Vocalists recording with monitoring effects.
* Live performers using DAW/live hosts (e.g. MainStage, Gig Performer, Cantabile).
* Content creators (Twitch, YouTube) who want instant “tuned + harmonized” vocals.

**Primary DAW formats (MVP)**

* **VST3** (Windows/macOS)
* **AU** (macOS)
* **(Phase 2)** AAX (Pro Tools)
* Sample rates: 44.1 kHz – 96 kHz.
* Buffer sizes: 32–1024 samples (optimized for 64–256).

---

## 2. Goals & Non-Goals

### 2.1 Goals (MVP)

1. **Reliable real-time pitch correction**

   * Transparent subtle tuning.
   * Fast, “robotic” tuning for modern trap/pop.
2. **Real-time harmonization**

   * Up to **3 harmony voices** + main vocal (4 total).
   * Musically aware diatonic harmonies in a selected key/scale.
   * Preset harmony patterns for instant “3rd up + 5th up” etc.
3. **Very low latency**

   * A “Live Mode” with <10 ms plugin latency at 44.1 kHz (excluding host I/O).
4. **Low CPU usage**

   * Efficient enough for multiple instances on a typical modern laptop.
5. **Simple, quick UI (Auto Mode)**

   * Key/scale selection.
   * One main “Correction strength” control (Retune Speed).
   * Harmony presets + simple per-voice controls.
6. **Robust DAW integration**

   * Proper parameter automation.
   * Stable preset handling.
   * Cross-platform consistency.

### 2.2 Non-Goals (MVP / Phase 2+ instead)

* No **Graph/Editor Mode** (manual note drawing, detailed offline editing).
* No **ARA2** integration in MVP (planned for Phase 2).
* No complex **ML models** requiring big runtime libraries (keep binary small).
* No built-in reverb/delay/etc. (this is a tuner+harmonizer, not full FX rack).

---

## 3. Core User Flows

### 3.1 “Drop it on a track and fix a vocal quickly”

1. Insert NovaTune on a vocal track.
2. Set **Key** + **Scale** (or choose “Chromatic”).
3. Set **Input Type** (Soprano/Alto/Tenor/Low Male).
4. Turn **Retune Speed** to taste.
5. Optionally enable **1–3 harmony voices** via a preset (e.g., “Pop 3rds & 5ths”).
6. Print / bounce track, or keep in session.

### 3.2 Tracking & monitoring with harmonies

1. Singer records while hearing auto-tuned voice and harmonies in headphones.
2. DAW buffer kept low (64–128 samples).
3. Harmony voices follow the lead vocal’s melody and chosen key/scale.

### 3.3 Building harmonies from scratch

1. User sets key/scale.
2. Enables harmony voice A:

   * Interval: “+3rd above”
3. Enables harmony voice B:

   * Interval: “-3rd below”
4. Adjusts individual levels, stereo position, and timing/pitch humanization.
5. Saves as a **user preset**.

---

## 4. Feature Breakdown

### 4.1 Pitch Correction (Lead)

**MVP capabilities:**

* Real-time **monophonic pitch detection**.
* Key/scale mapping:

  * Common scales: Major, Natural Minor, Harmonic Minor, Melodic Minor, Chromatic.
  * Future: modes (Dorian, Phrygian, etc.).
* Frame-wise **pitch correction**:

  * Retune Speed (controls how fast pitch is pulled to target).
  * Humanization (preserves longer notes, reduces robotic sound).
* Optional **Vibrato control**:

  * Vibrato Amount: reduce or enhance natural vibrato.
* **Input Type** presets:

  * Soprano
  * Alto/Tenor
  * Low Male
  * Instrument
  * These alter internal pitch detection ranges/windowing.

**Phase 2+ ideas (not required in MVP but keep in mind):**

* Separate controls for onset handling vs sustained notes.
* Advanced vibrato detection and selective preservation.

### 4.2 Vocal Harmonizer

**MVP harmonizer capabilities:**

* Up to **3 harmony voices** (A, B, C).
* Voices generated by:

  * Duplicating the input signal (post-pitch-detection, pre-correction or post-correction; design below).
  * Applying independent **pitch shift** to each voice.
* Harmony interval options:

  * **Diatonic intervals** relative to detected note in key/scale:

    * Examples: Unison, 2nd, 3rd, 4th, 5th, 6th, 7th above or below.
  * **Fixed semitone offsets**:

    * -12 to +12 semitones (for chromatic/creative uses).
* Per-voice parameters:

  * **Enabled** (On/Off).
  * **Mode**: Diatonic / Semitone.
  * **Interval**: (e.g., +3rd, -5th, +7 semitones).
  * **Level**: -∞ to +6 dB.
  * **Pan**: -100% (L) to +100% (R).
  * **Formant Shift**: -6 to +6 “formant semitones” (avoid chipmunk effect).
  * **Timing Humanize**: 0–30 ms random delay per phrase.
  * **Pitch Humanize**: 0–15 cents random pitch deviation.

**Harmony presets (MVP)**

Preset list accessible via dropdown (examples):

* **None** – (all harmonies off).
* **Pop 3rd Up** – A = +3rd above.
* **Pop 3rd & 5th Up** – A = +3rd above, B = +5th above.
* **Thirds Above & Below** – A = +3rd, B = -3rd.
* **Fifths Wide** – A = +5th, B = -5th, pan hard left/right.
* **Octave Double** – A = +12 semitones.
* **Octave + 3rd** – A = +12, B = +3rd.
* **Choir Stack** – A = +3rd, B = -3rd, C = +5th (lighter levels, spread pan).

Users can **save custom presets** with their own per-voice settings.

### 4.3 UI – Auto Mode (MVP only)

**Main Panel**

* **Key selector** (C, C#, D, …, B).
* **Scale selector** (Major, Minor, Chromatic, etc.).
* **Input Type** dropdown.
* **Retune Speed** (big main knob).
* **Humanize** knob.
* **Vibrato Amount** knob (optional in MVP, but useful).
* **Mix / Dry-Wet** knob:

  * 0–100% (for parallel tuning FX).

**Harmony Panel**

* Harmony Preset dropdown.
* For each voice (A/B/C), a small panel with:

  * On/Off toggle.
  * Mode (Diatonic/Semitone).
  * Interval selector (list or knob).
  * Level fader.
  * Pan knob.
  * Formant shift knob.
  * Humanize knobs (Timing, Pitch) – can combine into one “Humanize” knob per voice in MVP if needed.

**Visuals**

* Simple **pitch meter**:

  * “Detected note” vs “Target note(s)” indicator.
  * Basic scrolling pitch trace (low-resolution is fine) for user confidence.
* Level meters:

  * Input and Output meters (stereo).

**Global UI elements**

* Bypass button.
* Latency/quality mode indicator (Live / Mix).
* Preset browser.
* Settings menu (buffer size info, oversampling if any, hold-tooltips on/off).

---

## 5. Parameters (for Host Automation)

### 5.1 Global / Lead Parameters

* `key` (enum: C–B, plus None/Auto later).
* `scale` (enum: Major, NaturalMinor, HarmonicMinor, MelodicMinor, Chromatic).
* `input_type` (enum: Soprano, AltoTenor, LowMale, Instrument).
* `retune_speed` (float, 0–100; mapped internally to ms).
* `humanize` (float, 0–100).
* `vibrato_amount` (float, 0–100).
* `mix` (float, 0–100, percent wet).
* `bypass` (bool).

### 5.2 Harmony Voice Parameters (per voice A/B/C)

Per voice `v` in {A, B, C}:

* `v_enabled` (bool).
* `v_mode` (enum: Diatonic, Semitone).
* `v_interval_diatonic` (enum: -7 to +7 scale degrees; UI labels like “-5th”, “+3rd”).
* `v_interval_semitones` (int: -12 to +12).
* `v_level` (float: -48 to +6 dB).
* `v_pan` (float: -1.0 to +1.0).
* `v_formant_shift` (float: -6.0 to +6.0).
* `v_humanize_timing` (float: 0–30 ms).
* `v_humanize_pitch` (float: 0–15 cents) – or combine into a single 0–100.

### 5.3 System / Quality Parameters

* `quality_mode` (enum: Live, Mix).
* (Optionally) `oversampling` (enum: 1x, 2x, 4x) – could be Phase 2.

---

## 6. Technical Architecture

### 6.1 Tech Stack

* **Language:** C++17 or newer.
* **Framework:**

  * DSP + UI: **JUCE** (primary choice), or **iPlug2** if preferred.
  * Plugin formats via JUCE: VST3, AU, (later AAX).
* **Build system:** CMake (recommended), or Projucer projects generated + CMake wrapper.
* **Platforms:** macOS (Intel + Apple Silicon), Windows 10+ x64.

### 6.2 High-Level Module Diagram

**Audio thread (real-time)**

1. **Input Buffer**
2. **Pitch Detection Module**
3. **Pitch Mapping Module** (key/scale mapping)
4. **Lead Correction Module** (time-varying pitch shift)
5. **Harmony Generation Module**

   * For each voice:

     * Pitch shift
     * Formant shift
     * Humanization (timing offset & pitch jitter)
6. **Mixing & Output**
7. **Meters & visual taps** (with ring buffers to UI thread)

**UI thread (message thread)**

* Parameter controls → atomic/shared state → DSP.
* Displays for pitch/frequency, meters, graphs.
* Preset browsing, saving/loading.

**Hauskeeping / Non-RT thread**

* Preset management (file I/O).
* Any heavy key-detection analysis (Phase 2).
* Potential background ML or offline analysis later.

### 6.3 DSP Details (MVP)

#### 6.3.1 Pitch Detection

* Time-domain + frequency-domain hybrid:

  * Start with **YIN** or improved autocorrelation for F0 per frame.
  * Frame size: ~10–20 ms, hop ~5–10 ms (tunable).
* **Voice-specific tuning**:

  * Input Type clamps search range.
* Output:

  * F0 (Hz).
  * Voiced/unvoiced flag.
* Implement with:

  * Pre-allocated buffers, no dynamic allocation in processBlock.
  * Optionally compute in **smaller subsized sub-blocks** to reduce latency.

#### 6.3.2 Pitch Mapping & Note Targets

* Convert F0 to MIDI note `n_detect`.
* Use key/scale to map to nearest allowed note `n_target`.
* For harmonies:

  * Diatonic: note offsets in scale degrees relative to `n_target` (or `n_detect` depending on design).
  * Semitone: simply add offset to `n_target` or `n_detect`.

#### 6.3.3 Pitch Shifting / Correction Engine

* Use a **time-domain pitch shifter** (e.g., WSOLA / PSOLA variant) for low latency:

  * Good for monophonic vocal.
  * Minimal internal latency (1–2 pitch periods).
* Lead correction:

  * Maintain a target instantaneous pitch ratio `r(t) = f_target(t) / f_actual(t)`.
  * Smooth this ratio using a retune speed parameter:

    * Exponential smoothing: `r_smooth(t) = r_smooth(t-1) + alpha * (r(t) - r_smooth(t-1))`.
    * `alpha` derived from `retune_speed` / sample rate.
  * Apply pitch shift using WSOLA/PSOLA.

#### 6.3.4 Harmonizer Engine

* For each harmony voice:

  * Decide whether to:

    * Use **post-correction** as base (so harmonies follow corrected pitch).
    * Or base them directly on detected pitch for more “natural” but inconsistent harmonies.
  * MVP: base harmonies on **corrected lead** to keep them tight.

* For each voice:

  * Compute target ratio `r_voice(t)` from interval (in semitones):
    `r_voice = 2^(interval_semitones / 12)`.
  * Possibly combine with lead’s pitch ratio if we want harmonies to track the same retune curves.
  * Apply pitch shift (reuse same WSOLA/PSOLA engine, but separate state).
  * Apply **formant shift**:

    * Simple formant-shift approach:

      * Split signal with a short FFT (small window, e.g., 1024 samples).
      * Apply a mild spectral envelope warp to simulate vocal tract adjustment.
      * Alternatively, apply a formant-correcting pitch shift (resampling vs phase vocoder mix).
    * For MVP, we can implement a basic **formant-preserving** pitch shift plus a formant “tilt” EQ or simple spectral warp.
  * Apply humanization:

    * Timing: per phrase or buffer, delay voice by random amount up to `v_humanize_timing` (implemented as a small circular buffer).
    * Pitch: add a small random LFO within ±`v_humanize_pitch` cents.

* Mix all voices (and dry if mix < 100%) with correct latency compensation.

### 6.4 Latency Strategy

* **Live Mode**

  * Target plugin latency ≤ 64 samples at 44.1 kHz (~1.45 ms), plus internal WSOLA window overhead.
  * Aim for: **plugin-reported latency = 0** or very small (64–128 samples), so host does not add extra big buffering.
  * Slightly noisier pitch estimates tolerated.

* **Mix Mode**

  * Allow more internal lookahead (e.g., 5–10 ms).
  * Plugin latency might be ~256–512 samples at 44.1 kHz (5.8–11.6 ms).
  * Higher quality smoothing, better vibrato preservation.

Implementation notes:

* Provide `getLatencySamples()` accordingly.
* Ensure any internal delay lines are consistent across lead and harmony paths to avoid comb artifacts.

### 6.5 Performance & Resource Considerations

* No dynamic memory allocation in `processBlock`.
* Use **SIMD** where beneficial:

  * Pitch detection correlation loops.
  * FFT operations (if using FFT for formant).
* Pre-allocate harmonizer states per max voices (3).
* Provide **max block size** assumption (e.g., up to 2048 samples).
* Avoid heavy logging or debug in real-time paths.

---

## 7. Presets & Configuration

### 7.1 Factory Presets (MVP)

* **Subtle Pop Lead**
* **Modern Trap Hard-Tune**
* **Natural Vocal Tightener**
* **Pop 3rd Harmony**
* **Pop 3rd & 5th**
* **Choir Stack (Light)**
* **Octave Doubler**
* **Octave + Third Lead**

Each preset stores:

* Key (default: C Major).
* Scale.
* Input Type (Alto/Tenor default).
* Retune Speed, Humanize, Vibrato.
* Harmony voice configs.

### 7.2 User Presets

* Stored as JSON/XML and managed via JUCE’s preset system.
* Support **save**, **load**, **rename**, **delete**.
* Optional directories per user.

---

## 8. Future Phases (Design Hooks)

We’ll leave hooks in the architecture for:

* **Graph/Editor Mode** (Pitch timeline) via additional view + offline edit buffer.
* **ARA2 integration** (Logic, Studio One).
* **Global Key Detection plugin** that broadcasts key/scale to all NovaTune instances.
* Optional **GPU-accelerated** offline batch processing.

---

## 9. Deliverables for MVP

### 9.1 Core Implementation Tasks

1. JUCE project setup (CMake, VST3/AU targets).
2. Parameter model and state management.
3. Pitch detection module.
4. Lead correction module (WSOLA/PSOLA).
5. Harmony generation (3 voices) + formant shift minimal implementation.
6. Audio I/O handling & latency reporting.
7. UI implementation:

   * Auto Mode view.
   * Harmony voice panels.
   * Metering and basic pitch display.
8. Preset system & factory presets.
9. Platform builds:

   * Windows x64 VST3.
   * macOS (Intel + ARM) AU + VST3.

### 9.2 Testing

* Test across multiple DAWs:

  * Ableton Live, FL Studio, Logic, Reaper, Studio One.
* Latency/performance tests:

  * Different buffer sizes and sample rates.
* Subjective tuning quality tests:

  * Spoken voice, sung leads, stacked harmonies.
* Edge cases:

  * Fast runs, vibrato, sibilance-heavy vocals.
